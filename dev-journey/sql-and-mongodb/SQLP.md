# SQL 파싱과 최적화
SQL 최적화는 SQL 파싱 → SQL 최적화 → 로우 소스 생성 순서로 진행한다.

### SQL 파싱
사용자로부터 SQL을 받으면 가장 먼저 SQL 파서가 파싱을 진행한다.
- 파싱 트리 생성
- Syntax 체크
- Semantic 체크


### SQL 최적화
옵티마이저(Optimizer)가 최적화를 한다.

### 로우 소스 생성
옵티마이저가 선택한 실행결로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계.

### SQL 옵티마이저
SQL 옵티마이저를 백그라운드 프로세스로 생각하기 쉬운데, 별도의 프로세스가 아니라 서버 프로세스가 가진 기능(Function)일 뿐이다.
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해서 각 실행계획의 예상비용을 산정한다.
3. 최저 비용인 실행계획을 선택한다.

### 비용(Cost)
비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값이다.
- 어디까지나 예상치이기 때문에, 실제 수행했을 때 발생하는 비용과는 차이가 있다.

### 옵티마이저 힌트
옵티마이저 힌트로 데이터 엑세스 경로를 바꿀 수 있다.
1. /*+ INDEX(A 고객_PK) */
2. 힌트 안에 인자를 나열할 땐 ,(콤마)를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.
3. 테이블을 지정할 때는 스키마명까지 명시하면 안 된다.
4. ALIAS를 지정했다면, 힌트에서도 ALIAS를 사용해야 한다.

▶ 옵티마이저 힌트를 쓸 거면, 빈틈없이 기술해야 한다.

자주 사용하는 힌트 목록  

## 소프트 파싱 vs 하드 파싱
소프트 파싱: SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것  
하드 파싱: 찾는데 실패하여 최적화 및 로우 소스 생성 단계까지 모두 거치는 것  

SGA 그림 1-4

### SQL 옵티마이저가 사용하는 정보
- 테이블, 컬럼, 인덱스 구조에 간한 기본 정보
- 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
- 시스템 통계: CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터
한 쿼리를 수행하기 위해 옵티마이저가 이렇게 많은 정보로 무수히 많은 실행경로를 도출하고 효율성을 판단해야 하기 때문에, SQL 최적화 과정은 결코 소프트할 수 없다.

### 이름없는 SQL 문제


## 데이터 저장 구조 및 I/O 메커니즘
I/O 튜닝이 곧 SQL 튜닝이라고 해도 과언이 아니다.  
SQL이 느린 이유는 십중팔구 I/O 때문이다.

### 데이터베이스 저장 구조
그림 1-10  
- 테이블 스페이스
    - 세그먼트를 담는 컨테이너
- 세그먼트 (테이블)
    - 데이터 저장공간이 필요한 오브젝트(테이브, 인덱스, 파티션, LOB 등)
- 익스텐트
    - 공간을 확장하는 단위
    - 연속된 블록들의 집합
    - 한 익스텐트는 하나의 테이블이 독점. 특, 한 익스텐트에 담긴 블록은 모두 같은 블록이다.
- 블록
    - 실제 레코드가 저장되는 곳
    - 데이터를 읽고 쓰는 단위 (오라클 디폴트는 8KB)
    - 한 블록은 하나의 테이블이 독점. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다.
    - 테이블 뿐만이 아니라 인덱스도 블록 단위로 읽고 쓴다.ㅇ
    - DB2, SQL Server같은 DBMS에서는 페이지라는 용어로 불림.

그림 1-11
- 파일 경합을 줄이기 위해 DBMS는 데이터를 가능한 한 여러 데이터 파일로 분산해서 저장함.
- 익스텐트 내 블록은 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아니다.

**DBA (Data Block Address)**
- 모든 데이터 블록은 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는다.
- 인덱스로 레코드를 읽을 때는 인덱스 ROWID를 사용한다. ROWID는 DBA + 로우번호(블록 내 순번)로 구성된다.
- 테이블을 스캔할 땐 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.


### 시퀀셜 액세스 vs 랜덤 액세스
그림 1-17  

오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 **맵**으로 관리한다.  
읽어야할 익스텐트를 익스텐트 맵에서 찾고, 얻은 각 익스텐트의 첫 번째 블록 뒤에 연속된 블록을 순서대로 읽으면 **Full Table Scan**이다.

랜덤 액세스는 논리적, 물리적인 순서를 따르지 않고, 한 블록씩 접근(=touch)하는 방식이다.


### 논리적 I/O vs 물리적 I/O
자주 읽는 블록을 매번 읽어 오는 것은 비효율적이기 때문에, 데이터 캐싱 메커니즘은 필수다.
- 라이브러리 캐시: SQL, 실행계획, DB저장형 함수 및 프로시저 등을 캐싱하는 코드 캐시
- DB 버퍼 캐시: 데이터 블록을 캐싱하는 데이터 캐시

데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다.
- 논리적 I/O: 메모리에서 블록 I/O할 때
- 물리적 I/O: 디스크에서 블록 I/O할 때
 
**버퍼캐시 히트율 (Buffer Cache Hit Ratio, BCHR)**
- BCHR
    - (캐시에서 곧바로 찾은 블럭 수 / 총 읽은 블록 수) * 100
    - ( (논리적 I/O - 물리적 I/O) / 논리적 I/O ) * 100
    - ( 1 - (물리적 I/O / 논리적 I/O) ) * 100
- 보통 온라인 트랜잭션을 주로 처리하는 애플리케이션은 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.
- BCHR 공식을 변경하면
    - 물리적 I/O = 논리적 I/O * (100% - BCHR)

BCHR 공식을 이루는 물리적 I/O는 통제 불가능한 외생변수다. 이것을 줄일 방법은 없다. 반면, 논리적 I/O는 통제 가능한 내생변수다. 그러므로 ***SQL을 튜닝해서 논리적 I/O를 줄이면 물리적 I/O도 줄고, 그만큼 성능도 향상된다.***

BCHR이 SQL 성능을 좌우하지만, BCHR이 높은게 효율적인 SQL을 보장하지는 않는다. 예를 들면, 한 번만 읽어도 될 블록을 비효율적으로 여러번 반복해서 읽어도 BCHR이 올라가기 때문이다.


### Single Block I/O vs Multiblock I/O
- I/O Call: 캐시에서 데이터 블록을 찾지 못하면 I/O Call을 통해 디스크에서 DB 버퍼 캐시로 적재하고서 읽음.
- Single Block I/O: I/O Call을 할 때, 한 번에 한 블럭씩 요청해서 메모리에 적재
- Multiblcok I/O: I/O Call을 할 때, 한 번에 여러 블록씩 요청해서 메모리에 적재

그림 1-24
- 인덱스를 사용할 때는, 기본적으로 인덱스와 테이블 블록 모두 Single Blcok I/O방식을 사용한다. 인덱스는 소량 데이터를 읽을 때 주로 사용하기 때문.
- Single Block I/O 대상 오퍼레이션
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 전체를 스캔할 때는 Multiblock I/O 방식을 사용한다.
    - 테이블이 클수록 Full Scan할 때, Multiblock I/O 단위가 크면 좋다.
    - 일반적으로 OS 레벨 I/O 단위가 1MB이고, 오라클 레벨 I/O 단위가 8KB이므로, 파라미터를 128로 설정하면 담을 수 있는 만큼 최대한 담을 수 있다.
- Multiblock I/O 방식은 인접한 여러 블록을 읽기 때문에, 익스텐트 경계를 넘지 못한다.
    - 그래서 더 읽기 위해 다음 익스텐트까지 읽지 않는다.

### Table Full Scan vs Index Range Scan(인덱스를 이용한 테이블 엑세스)
- Table Full Scan: 전체를 읽음
- 인덱스를 이용한 테이블 엑세스: 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식

Table Full Scan이 SQL 성능 향상에 도움이 될 때도 있다. 불필요하게 인덱스를 타고 있는지를 주의하자.
- 집계용 SQL과 배치 프로그램에서 특히 그렇다.
- 조인을 포함한 SQL이면, 조인 메소드로 해시 조인을 선택해주면 된다.

### 캐시 탐색 메커니즘
그림 1-27

- 버퍼캐시에서 블록을 찾을 때는, 해시 알고리즘으로 버퍼 헤더를 찾고, 여기서 얻은 포인터로 버퍼 블록을 엑세스한다.
- 해시 구조의 특징
    - 같은 입력 값은 항상 동일한 해시 체인(=버킷)에 연결됨
    - 다른 입력값이 동일한 해시 체인에 연결될 수 있다
    - 해시 체인 내에서는 정렬이 보장되지 않는다

**메모리 공유자원에 대한 엑세스 직렬화**  
버퍼캐시는 SGA 구성요소이므로 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이다. 이 때, 하나의 버퍼블록을 두 개 이상의 프로세스가 동시에 접근하면 블록 정합성에 문제가 생길 수 있다.
- 이를 해결하기 위해 직렬화(serialization) 메커니즘이 필요하다. → 래치(Latch)
    - 캐시버퍼 체인 래치
        - 키를 획득한 프로세스만이 해시 체인으로 진입할 수 있다.
    - 캐시버퍼 LRU 체인 래치
    - 래치에 의한 경합이 생길 수도 있다.
- 버퍼블록 자체에도 직렬화 메커니즘이 있다.
    - 버퍼 Lock
        - 읽고자하는 블록을 찾았으면, 캐시버퍼 체인 래치를 즉시 해제해야 한다. 그런데 래치를 해제한 상태로 버퍼블록 데이터를 읽고 쓰는 도중에 후행 프로세스가 하필 같은 블록에 접근해서 데이터를 읽고 쓴다면, 데이터 정합성에 문제가 생길 수 있다.

<br>
<br>

# 인덱스
인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용. ex) 온라인 트랜잭션 처리(OLTP)

**인덱스 튜닝의 두 가지 핵심요소**
1. 인덱스 스캔 과정에서 발생하는 비효율을 줄이기 ▶ **인덱스 스캔 효율화 튜닝**
2. 테이블 엑세스 횟수를 줄이기 ▶ **랜덤 엑세스 최소화 튜닝**

둘 다 중요한 튜닝이지만, 랜덤 엑세스 최소화 튜닝이 성능에 영향을 많이 끼친다.  
즉, ***SQL 튜닝은 랜덤 I/O와의 전쟁이다.***

## 인덱스 구조 및 탐색
인덱스는 정렬돼 있기 때문에, 일부만 읽고 멈추는 범위 스캔(Range)이 가능하다.  
- DBMS는 일반적으로 B-Tree 인덱스를 사용한다.
- LMC(Leftmost Child)는 자식 노드 중 가장 왼쪽 끝에 위치한 블록이다.
- 인덱스 키값이 같으면 ROWID 순으로 정렬된다.

### 인덱스 수직적 탐색
- 인덱스 스캔 시작지점을 찾는 과정
- 즉, 조건을 만족하는 첫 번째 레코드를 찾는 과정

### 인덱스 수평적 탐색
- 본격적으로 데이터를 찾는 과정
- 수직적 탐색으로 스캔 시작지점을 찾은 후에, 찾고자 하는 데이터가 더 이상 안 나올 때까지 인덱스 리프 블록을 수평적으로 스캔함.
- 수평적 탐색을 하는 이유
    1. 조건을 만족하는 모든 데이터를 찾기 위해
    2. ROWID를 얻기 위해

### 결합 인덱스 구조와 탐색
- 두 개 이상의 컬럼을 결합해서 인덱스로 만들 수도 있다.
- 인덱스 선두 컬럼을 모두 = 조건으로 검색할 때는, 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.
- B-Tree 인덱스에서는 delete 작업으로 인덱스가 불균형(Unbalanced)이 될 수가 없다.

## 인덱스 사용법
인덱스는 Range Scan이므로, 시작점을 찾을 수 있어야 하고, 스캔 도중에 멈출 수 있어야 한다.
- 가공한 값이나 중간값으로는 스캔 시작점을 찾을 수 없다.
- 찾고자 하는 단어가 흩어져 있으면 멈출 수가 없다.

### 인덱스를 Range Scan할 수 없는 경우
p. 86~
- 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다.
    - where substr(생년월일, 5, 2) = '05'
    - where nvl(주문수량, 0) < 100
    - where 업체명 like %대한%
    - where (전화번호 = :tel_no OR 고객명 = :cust_nm)
    - where 전화번호 in (:tel_no1, :tel_no2)
- OR은 OR Expansion 으로 해결.
    - or 기준으로 분리하여 union all을 한다.
- IN은 SQL 옵티마이저가 IN-List Iterator 방식을 사용함.
    - union all을 자동으로 실행함.
----
- 인덱스를 Range Scan하려면, 인덱스 선두 컬럼이 조건절에 있어야 한다.
    - 부서/이름/나이 로 구성된 인덱스에서 홍길동이름을 찾으려면 풀스캔해야 한다.
    - 반면에, 조건을 부서 = C 라고 시작한다면 인덱스를 사용할 수 있다.

***▶ 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan이 무조건 가능하다.***

인덱스를 잘 타는 지는 인덱스 리프 블록에서 스캔하는 양을 따져야 한다.

### 인덱스를 이용한 소트 연산 생략
- 인덱스 Range Scan은 데이터가 정렬되어 있기 때문에, ORDER BY 연산을 생략할 수도 있다.
- 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문에, 내림차순(DESC)도 생략할 수 있다.
- 확인 방법
    - 실행계획에서 SORT (ORDER BY)
    - 실행계획에서 INDEX (RANGE SCAN DESCENDING)

### ORDER BY절, SELECT-LIST에서 컬럼 가공
"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없었다." 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공해서 인덱스를 정상적으로 못 쓰는 경우도 있다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번

SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```

p.99 예시 참고

인덱스를 이용하면, 정렬 연산없이도 최소최대값을 빠르게 찾을 수 있다.  
p.100 실행계획 참고

p.101~103 예시 참고.

### 자동 형변환
DBMS는 타입이 일치 않을 경우, 자동으로 형변환한다. 이 때문에 오류 및 성능저하가 발생하므로, **꼭 인덱스 컬럼 기준으로 반대편 컬럼이나 값의 타입을 명시적으로 형변환**해주는게 좋다.

- 숫자와 문자가 만나면 숫자가 이긴다.
    - 단, 문자가 숫자로 바뀔 수 없다면 에러발생
    - 단, LIKE 연산자를 사용하면 숫자가 문자로 바뀐다.
- 날짜와 문자가 만나면 날짜가 이긴다.
- TO_CHAR, TO_DATE, TO_NUMBER 를 명시적으로 쓸 것.

## 인덱스 확장기능 사용법
Index Range Scan 외에도 Index Full Scan, Index Unique Scan, Index Skip Scan, Index Fast Full Scan 등이 있다.  
***▶ 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 하며, 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때, 이들 스캔 방식을 차선택으로 활용하는 것이 바람직하다.***

### Index Range Scan
- B-Tree 인덱스의 가장 일반적인 엑세스 형태
- 선두 컬럼이 가공되지 않은 상태로 조건절에서 사용되어야 함

### Index Full Scan
- 인덱스 리프 블록을 처음부터 끝까지 수평적 탐색
- 주로 검색을 위한 최적의 인덱스가 없을 때, 차선책으로 사용
- ex) 선두 컬럼이 조건절에 없을 때
- Index Full Scan의 효용성
    - 면적이 큰 전체 테이블을 스캔하기 보다는 인덱스만을 스캔하는 쪽이 유리할거다.
- 결과집합이 인덱스 컬럼 순으로 정렬되므로 Sort Order By 연산을 생략할 수도 있다.

### Index Unique Scan
- 수직적 탐색만으로 데이터를 찾음.
- 그래서 Unique 인덱스를 = 조건으로 탐색할 때만 작동 (unique key)

### Index Skip Scan
- 오라클에 있는 방식
- 조건절에서 빠진 인덱스 선두 컬럼의 Distinct Value 수가 적고, 후행 컬럼의 Distinct Value 수가 많을 때 유용함.
- 루트 블록 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해서, 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 엑세스하는 방식
- 중간 컬럼에 대한 조건절이 없는 경우도 일부 가능하다. p.120
- Distinct Value 수가 적은 두 개의 선두 컬럼 모두가 조건절에 없어도 가능. p.120
- 선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위 검색 조건일 때도 사용 가능. p.121

### Index Fast Full Scan
- Index Full Scan은 논리적 구조에 따라 읽는 반면, Index Fast Full Scan은 논리적인 인덱스 트리를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔한다.
- 물리적으로 저장된 순서로 읽기 때문에, 결과 집합이 인덱스 키 순서대로 정렬되지 않는다.
- 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있어야 한다.
- ? 인덱스가 파티션 돼 있지 않더라도 병렬 쿼리가 가능한 것도 특징이다. 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.

| Index Full Scan | Index Fast Full Scan |
|---|---|
|   |   |
|   |   |
|   |   |
|   |   |
|   |   |

### Index Range Scan Descending
- Index Range Scan을 뒤에서부터 앞쪽으로 스캔하기 때문에, 결과집합이 내림차순으로 정렬된다.
- DESC로 안되면, index_desc 힌트로도 유도 가능.
- MAX 값을 구하고자 할 때도 사용됨.


<br>
<br>

# 인덱스 튜닝

## 테이블 엑세스 최소화
SQL 튜닝은 랜덤 I/O 와의 전쟁이다.

### 테이블 랜덤 엑세스
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니라면, 인덱스를 스캔한 후에 반드시 테이블을 엑세스 한다.

인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻으려는 것이다.

ROWID는 물리적 주소보다는 논리적 주소에 가깝다. 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. 포인터가 아니며, 테이블 레코드와 물리적으로 직접 연결된 구조는 더더욱 아니다.


메인 메모리 DB (MMDB)
- 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB

오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조다. 그래서 포인터가 아닌 DBA(Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

### I/O 메커니즘 복습
DBA(= 데이터파일번호 + 블록번호)는 디스크 상에서 블록을 찾기 위한 주소 정보다.

