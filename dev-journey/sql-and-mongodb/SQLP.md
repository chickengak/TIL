# SQL 파싱과 최적화
SQL 최적화는 SQL 파싱 → SQL 최적화 → 로우 소스 생성 순서로 진행한다.

### SQL 파싱
사용자로부터 SQL을 받으면 가장 먼저 SQL 파서가 파싱을 진행한다.
- 파싱 트리 생성
- Syntax 체크
- Semantic 체크


### SQL 최적화
옵티마이저(Optimizer)가 최적화를 한다.

### 로우 소스 생성
옵티마이저가 선택한 실행결로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계.

### SQL 옵티마이저
SQL 옵티마이저를 백그라운드 프로세스로 생각하기 쉬운데, 별도의 프로세스가 아니라 서버 프로세스가 가진 기능(Function)일 뿐이다.
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해서 각 실행계획의 예상비용을 산정한다.
3. 최저 비용인 실행계획을 선택한다.

### 비용(Cost)
비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값이다.
- 어디까지나 예상치이기 때문에, 실제 수행했을 때 발생하는 비용과는 차이가 있다.

### 옵티마이저 힌트
옵티마이저 힌트로 데이터 엑세스 경로를 바꿀 수 있다.
1. /*+ INDEX(A 고객_PK) */
2. 힌트 안에 인자를 나열할 땐 ,(콤마)를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.
3. 테이블을 지정할 때는 스키마명까지 명시하면 안 된다.
4. ALIAS를 지정했다면, 힌트에서도 ALIAS를 사용해야 한다.

▶ 옵티마이저 힌트를 쓸 거면, 빈틈없이 기술해야 한다.

자주 사용하는 힌트 목록  

## 소프트 파싱 vs 하드 파싱
소프트 파싱: SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것  
하드 파싱: 찾는데 실패하여 최적화 및 로우 소스 생성 단계까지 모두 거치는 것  

SGA 그림 1-4

### SQL 옵티마이저가 사용하는 정보
- 테이블, 컬럼, 인덱스 구조에 간한 기본 정보
- 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
- 시스템 통계: CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터
한 쿼리를 수행하기 위해 옵티마이저가 이렇게 많은 정보로 무수히 많은 실행경로를 도출하고 효율성을 판단해야 하기 때문에, SQL 최적화 과정은 결코 소프트할 수 없다.

### 이름없는 SQL 문제


## 데이터 저장 구조 및 I/O 메커니즘
I/O 튜닝이 곧 SQL 튜닝이라고 해도 과언이 아니다.  
SQL이 느린 이유는 십중팔구 I/O 때문이다.

### 데이터베이스 저장 구조
그림 1-10  
- 테이블 스페이스
    - 세그먼트를 담는 컨테이너
- 세그먼트 (테이블)
    - 데이터 저장공간이 필요한 오브젝트(테이브, 인덱스, 파티션, LOB 등)
- 익스텐트
    - 공간을 확장하는 단위
    - 연속된 블록들의 집합
    - 한 익스텐트는 하나의 테이블이 독점. 특, 한 익스텐트에 담긴 블록은 모두 같은 블록이다.
- 블록
    - 실제 레코드가 저장되는 곳
    - 데이터를 읽고 쓰는 단위 (오라클 디폴트는 8KB)
    - 한 블록은 하나의 테이블이 독점. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다.
    - 테이블 뿐만이 아니라 인덱스도 블록 단위로 읽고 쓴다.ㅇ
    - DB2, SQL Server같은 DBMS에서는 페이지라는 용어로 불림.

그림 1-11
- 파일 경합을 줄이기 위해 DBMS는 데이터를 가능한 한 여러 데이터 파일로 분산해서 저장함.
- 익스텐트 내 블록은 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아니다.

**DBA (Data Block Address)**
- 모든 데이터 블록은 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는다.
- 인덱스로 레코드를 읽을 때는 인덱스 ROWID를 사용한다. ROWID는 DBA + 로우번호(블록 내 순번)로 구성된다.
- 테이블을 스캔할 땐 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.


### 시퀀셜 액세스 vs 랜덤 액세스
그림 1-17  

오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 **맵**으로 관리한다.  
읽어야할 익스텐트를 익스텐트 맵에서 찾고, 얻은 각 익스텐트의 첫 번째 블록 뒤에 연속된 블록을 순서대로 읽으면 **Full Table Scan**이다.

랜덤 액세스는 논리적, 물리적인 순서를 따르지 않고, 한 블록씩 접근(=touch)하는 방식이다.


### 논리적 I/O vs 물리적 I/O
자주 읽는 블록을 매번 읽어 오는 것은 비효율적이기 때문에, 데이터 캐싱 메커니즘은 필수다.
- 라이브러리 캐시: SQL, 실행계획, DB저장형 함수 및 프로시저 등을 캐싱하는 코드 캐시
- DB 버퍼 캐시: 데이터 블록을 캐싱하는 데이터 캐시

데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다.
- 논리적 I/O: 메모리에서 블록 I/O할 때
- 물리적 I/O: 디스크에서 블록 I/O할 때
 
**버퍼캐시 히트율 (Buffer Cache Hit Ratio, BCHR)**
- BCHR
    - (캐시에서 곧바로 찾은 블럭 수 / 총 읽은 블록 수) * 100
    - ( (논리적 I/O - 물리적 I/O) / 논리적 I/O ) * 100
    - ( 1 - (물리적 I/O / 논리적 I/O) ) * 100
- 보통 온라인 트랜잭션을 주로 처리하는 애플리케이션은 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.
- BCHR 공식을 변경하면
    - 물리적 I/O = 논리적 I/O * (100% - BCHR)

BCHR 공식을 이루는 물리적 I/O는 통제 불가능한 외생변수다. 이것을 줄일 방법은 없다. 반면, 논리적 I/O는 통제 가능한 내생변수다. 그러므로 ***SQL을 튜닝해서 논리적 I/O를 줄이면 물리적 I/O도 줄고, 그만큼 성능도 향상된다.***

BCHR이 SQL 성능을 좌우하지만, BCHR이 높은게 효율적인 SQL을 보장하지는 않는다. 예를 들면, 한 번만 읽어도 될 블록을 비효율적으로 여러번 반복해서 읽어도 BCHR이 올라가기 때문이다.


### Single Block I/O vs Multiblock I/O
- I/O Call: 캐시에서 데이터 블록을 찾지 못하면 I/O Call을 통해 디스크에서 DB 버퍼 캐시로 적재하고서 읽음.
- Single Block I/O: I/O Call을 할 때, 한 번에 한 블럭씩 요청해서 메모리에 적재
- Multiblcok I/O: I/O Call을 할 때, 한 번에 여러 블록씩 요청해서 메모리에 적재

그림 1-24
- 인덱스를 사용할 때는, 기본적으로 인덱스와 테이블 블록 모두 Single Blcok I/O방식을 사용한다. 인덱스는 소량 데이터를 읽을 때 주로 사용하기 때문.
- Single Block I/O 대상 오퍼레이션
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 전체를 스캔할 때는 Multiblock I/O 방식을 사용한다.
    - 테이블이 클수록 Full Scan할 때, Multiblock I/O 단위가 크면 좋다.
    - 일반적으로 OS 레벨 I/O 단위가 1MB이고, 오라클 레벨 I/O 단위가 8KB이므로, 파라미터를 128로 설정하면 담을 수 있는 만큼 최대한 담을 수 있다.
- Multiblock I/O 방식은 인접한 여러 블록을 읽기 때문에, 익스텐트 경계를 넘지 못한다.
    - 그래서 더 읽기 위해 다음 익스텐트까지 읽지 않는다.

