# SQL 파싱과 최적화
SQL 최적화는 SQL 파싱 → SQL 최적화 → 로우 소스 생성 순서로 진행한다.

### SQL 파싱
사용자로부터 SQL을 받으면 가장 먼저 SQL 파서가 파싱을 진행한다.
- 파싱 트리 생성
- Syntax 체크
- Semantic 체크


### SQL 최적화
옵티마이저(Optimizer)가 최적화를 한다.

### 로우 소스 생성
옵티마이저가 선택한 실행결로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계.

### SQL 옵티마이저
SQL 옵티마이저를 백그라운드 프로세스로 생각하기 쉬운데, 별도의 프로세스가 아니라 서버 프로세스가 가진 기능(Function)일 뿐이다.
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해서 각 실행계획의 예상비용을 산정한다.
3. 최저 비용인 실행계획을 선택한다.

### 비용(Cost)
비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값이다.
- 어디까지나 예상치이기 때문에, 실제 수행했을 때 발생하는 비용과는 차이가 있다.

### 옵티마이저 힌트
옵티마이저 힌트로 데이터 엑세스 경로를 바꿀 수 있다.
1. /*+ INDEX(A 고객_PK) */
2. 힌트 안에 인자를 나열할 땐 ,(콤마)를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.
3. 테이블을 지정할 때는 스키마명까지 명시하면 안 된다.
4. ALIAS를 지정했다면, 힌트에서도 ALIAS를 사용해야 한다.

▶ 옵티마이저 힌트를 쓸 거면, 빈틈없이 기술해야 한다.

자주 사용하는 힌트 목록  

## 소프트 파싱 vs 하드 파싱
소프트 파싱: SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것  
하드 파싱: 찾는데 실패하여 최적화 및 로우 소스 생성 단계까지 모두 거치는 것  

SGA 그림 1-4

### SQL 옵티마이저가 사용하는 정보
- 테이블, 컬럼, 인덱스 구조에 간한 기본 정보
- 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
- 시스템 통계: CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터
한 쿼리를 수행하기 위해 옵티마이저가 이렇게 많은 정보로 무수히 많은 실행경로를 도출하고 효율성을 판단해야 하기 때문에, SQL 최적화 과정은 결코 소프트할 수 없다.

### 이름없는 SQL 문제


## 데이터 저장 구조 및 I/O 메커니즘
I/O 튜닝이 곧 SQL 튜닝이라고 해도 과언이 아니다.  
SQL이 느린 이유는 십중팔구 I/O 때문이다.

### 데이터베이스 저장 구조
그림 1-10  
- 테이블 스페이스
- 세그먼트 (테이블)
- 익스텐트
- 블록


