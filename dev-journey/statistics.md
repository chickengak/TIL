# Statistics

<br>
<br>

# 데이터

## 질적 변수 vs 양적 변수

### 질적 변수
> 1. 매우 좋음　　2. 좋음　　3. 보통　　4. 나쁨　　5. 매우 나쁨  
> A형　　B형　　O형　　AB형  

흡연여부, 남성과 여성 같이 값이 2개인 질적 변수는 __2진변수__ 라고 한다. True or False라서 1과 0으로 표현 가능하지만, 질적변수다.

#### __명의 척도__
명의 척도의 목적은 구별하는 것으로, 학생번호나 전화번호, 성별 등이 있다.

#### __순서 척도__
순서 관계나 __대소 관계__ 에 대한 의미만 있을 때. 성적 순위나 설문조사 만족도 등이 있다.  
8등과 4등의 차이가 8등과 12등과의 차이와 같다고 말하기 힘들고, 4등이 8등의 두배라고 하기 힘든 상황의 변수를 말함.

### 양적 변수
> 시험점수, 키

#### __간격 척도__
간격 척도는 대소 관계와 함께 그 __차이__ 에도 의미를 두는 변수. 연도나 온도 등이 있다.  
60도는 30도보다 높은 온도이므로 대소 관계에 의미가 있고 그 차이도 의미가 있다.  
하지만 60도는 30도보다 2배 높은 온도라고 말할 수 없기에 간격 척도다.

#### __비례 척도__
비례 척도는 __대소 관계, 차이, 비__ 모두 의미가 있는 변수. 길이, 무게 등이 있다.  
50cm와 100cm는 2배 차이라고 말할 수 있다.

- 간격 척도와 비례 척도 구분 Tip
    - 0이 없음을 뜻하는지 확인하면 된다.

<br>

## 이산형 변수 vs 연속형 변수
### 이산형 변수
0, 1, 2, 3, ... 같이 하나하나의 값을 취하는 변수.
### 연속형 변수
연속적인 값을 취하기에 두 숫자 사이에도 반드시 숫가가 있음. 계속 쪼개짐.

<br>
<br>
<br>

# 1차원 데이터
```
# 데이터 가져오기
df = pd.read_csv("etc/ch2_scores_em.csv", index_col="student number")
scores = np.array(df["english"])[:10]
scores_df = pd.DataFrame({"score":scores}, index=pd.Index(["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]), name = "studnet")
```
### 평균값 mean
다 아는 일반적인 평균. 시그마나 엑스바로 표현.
```
np.mean(scores)
score_df.mean()
```


### 중앙값 median
데이터를 크기 순으로 나열했을 때, 정중앙에 위치하는 값을 중앙값이라고 한다.  
중앙값은 평균값에 비해 이상값에 강하다.  
[1, 2, 3, 4, 5, 6, 1000]이 있을 때, 아주 큰 이상값 하나 때문에 평균값은 150이 되는데 이럴 때, 중앙값 4를 쓰는게 바람직할 수 있다.  
데이터가 짝수개일 때는 중앙에 있는 값 두개의 평균값을 중앙값으로 본다.
```
np.median(scores)
scores_df.median()
```


### 최빈값 mode
데이터에서 가장 많이 등장한 값.  
최빈값은 기본적으로 질적 데이터의 대푯값을 구할 때 사용하는 지표다. 시험점수같은 양적 데이터에서 최빈값을 구하는 것은 무의미해지기 쉽상이다.
```
pd.Series([1, 1, 1, 2, 2, 3]).mode()
```

### 분산 variance
__편차 deviation__ 은 각 데이터가 평균으로부터 얼마나 떨어져 있는 지를 보여준다. 이 때, 떨어진 정도는 음수와 양수 모두 가능하다.  
하지만 편차의 대푯값으로 평균을 선택하면 편차 평균 즉, 모든 편차의 합은 0이 된다.  
그래서 서로 다른 데이터더라도 평균만 같으면 두 데이터를 구분하고 분석할 수 없는 상황을 초래한다.<br>  
그 결과 평균에서 각각 10의 거리만큼 떨어진 +10인 값과 -10인 값을 동일한 산포도를 갖고 있다고 취급하자는 발상에서 __편차의 제곱 즉, 분산__ 을 정의하게 된다.
```
np.var(scores)
scores_df.var(ddof=0)
# Numpy는 표본분산이 default인 반면, Pandas는 불편분산이 default라 ddof라는 매개변수를 통해 표본분산으로 바꿨다.
```
분산은 $S^2$ 이라고 표기한다.  
분산을 면적의 평균이라고 보기도 한다. 한 변의 길이가 편차인 정사각형과 같기 때문.


### 표준편차 standard deviation
분산은 편차보다 산포도를 잘 보여주는것 같지만 제곱되면서 단위가 단위$^2$이 됐다. 때문에 한 눈에 파악하기 힘든 단위로 생기는 문제를 해결하고자 분산에 제곱근을 취한 __표준편차__ 를 정의하게 된다.
```
np.std(scores, ddof=0)
```
표준편차는 원래의 데이터와 동일한 단위를 쓰므로, 동일한차원으로 그릴 수 있다.
이 때, 평균 ± 표준편차구간을 1 시그마 구간, 평균 ±2 표준편차구간을 2 시그마 구간, 평균 ±3 표준편차구간을 3 시그마 구간이라고 한다. 이때, 각 구간은 정규분포의 약 68.27%, 95.45%, 99.73% 범위를 포함한다.

### 범위 range
범위는 데이터 전체를 보지 않고 최댓값과 최솟값만으로 산포도를 표현한다.  
간단히 계산 가능하지만 이상값에 약하다.
```
np.max(scores) - np.min(scores)
```

### 사분위 범위 IQR, interquartile range
범위가 이상값에 약하다는 단점을 커버하기 위해 상위수%와 하위수%를 이용한다.  
데이터의 하위 25%, 50%, 75%에 위치하는 값을 보고 이를 각각 제1사분위수, 제2사분위수, 제3분위수라고 하며 Q1, Q2, Q3라고도 표현한다. 그리고 Q3 - Q1을 __사분위 범위, IQR__ 이라고 한다.
```
scores_Q1 = np.percentile(scores, 25)
scores_Q3 = np.percentile(scores, 75)
scores_IQR = scores_Q3 - scores_Q1
```
#### 분산은 평균에 대해 정의되는 산포도인 반면, IQR은 중앙값에 대해 정의되는 산포도의 지표라고 해석할 수 있다.

## 데이터 정규화 normalization
60점
### 표준화 standardization
데이터에서 평균을 빼고 표준편차로 나누는 작업을 __표준화__ 라고 한다.  
표준화된 데이터는 표준화 변량 standardized data 혹은 Z 점수 z-score 라고 한다.
```
z = (scores - np.mean(scores)) / np.std(scores)
np.mean(z)              # 0  표준화된 데이터의 평균은 0
np.std(z, ddof=0)       # 1  표준화된 데이터의 표준편차는 1
```
원본 데이터와 동일한 단위를 쓰는 표준편차로 나눴기 때문에, 표준화된 데이터엔 단위가 없다.

### 편찻값
편찻값은 평균이 50, 표준편차가 10이 되도록 정규화한 값이다.  
```
z = 50 + 10 * (scores - np.mean(scores)) / np.std(scores)
```

## 1차원 데이터 시각화
```
english_scores = np.array(df["english"])   # 50명 영어점수 다 가져오기.
```

### 도수분포표 frequency distribution
분할된 구간에 데이터 개수를 표로 표현한 것.  
시험 점수를 0~10점, 10~20점, ... 구간으로 나눠서 도수분포표를 만든다면, 0~10점이라는 구간을 __계급 class__ 라고 하고, 각 계급에 속한 학생 수를 __도수 frequency__ 라고 하고, 각 구간의 폭을 __계급폭__ 이라 하고, 계급의 개수를 __계급수__ 라고 한다.
```
# bins로 계급수를. range로 최솟값과 최댓값을 지정.
freq, _ = np.histogram(english_scores, bins=10, range=(0, 100))
```
도수분포표를 이용하면 양적데이터도 최빈값을 구할 수 있다.    <br>  
__계급값__ : 각 계급을 대표하는값. 계급의 중간값을 이용.　　ex) 70~80의 계급값은 75.  
```
class_value = [(i+(i+10))//2 for i in range(0, 100, 10)]
```
__상대도수__ : 전체 데이터에서 해당 계급의 데이터가 갖는 비율.  
```
rel_freq = freq / freq.sum()
```
__누적상대도수__ : 상대도수의 누적합.
```
cum_rel_freq = np.cumsum(rel_freq)
```
<br>

### 히스토그램



### 상자그림


