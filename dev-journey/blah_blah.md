
### 컴파일러 vs 인터프리터

|       | 컴파일러             | 인터프리터                        |
|-------|------------------|------------------------------|
| 작동방식  | **소스코드를 기계어로 먼저 번역** <br> 해당 플랫폼에 최적화되어 프로그램을 실행. | 별도의 번역과정 없이 <br> **소스코드를 실행시점에 해석**하여 <br> 컴퓨터가 처리할 수 있게 함. |
| 장단점   | 실행속도가 빠름. <br> 한 번의 많은 기억장소 필요  | 실행속도가 느림. <br> 간단히 작성, 메모리가 적게 필요 |
| 주요 언어 | C, 자바,C++,C#...  | 파이썬, 스칼라..                   |

<br>

### 파이썬 특징
- 객체 지향
- Dynamic Typing 동적 타이핑 언어: 프로그램이 실행되는 시점에 프로그램이 사용해야할 데이터의 타입을 결정함.

<br>

### 복제
```python
a = [1,2,3,4,5]
b = a[:]
a[0]=100

'''
a = [100,2,3,4,5]
b = [1,2,3,4,5]
'''


a = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
c = a[:]
c[0][0]=100

'''
a = [[100, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
c = [[100, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
[:] 복제는 1차원에서만 작동.
'''

import copy
d = copy.deepcopy(a)        # 2차원 이상의 행렬은 deepcopy
a = [0][0] = 99
'''
a = [[99, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
d = [[100, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
'''


# m * n 0행렬 만들기
m = 3; n = 4
mat = [[0]*n]*m
mat[0][0] = 7
'''
mat =   [[7, 0, 0, 0],
         [7, 0, 0, 0],
         [7, 0, 0, 0]]
         모든 행이 같은 리스트를 참조함
'''

mat = [[0]*n for _ in range(m)]
mat[0][0] = 7
'''
mat =   [[7, 0, 0, 0],
         [0, 0, 0, 0],
         [0, 0, 0, 0]]
         이제야 모든 행이 다른 리스트를 참조함
'''
```

<br>

### is
== 연산은 값이 같은지를 확인하지만 is 연산은 메모리주소가 같은지를 확인한다.
```python
a = 100
b = 100
a is b          # True

a = 300
b = 300
a is b          # False

'''
위와 같은 결과가 발생하는 이유.
파이썬은 -5 ~ 256 까지의 자주 쓰이는 수는 같은 메모리주소를 참조하게 했기 때문에
발생하는 현상.
'''
```

<br>

### all, any
```python
boolean_list = [True, False, True, False, True]
all(boolean_list)           # False
any(boolean_list)           # True 
```

### 삼항연산자 = Ternary operators